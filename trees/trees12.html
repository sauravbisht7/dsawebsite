<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body style="background-color: black;">
    <pre>
        <code style="color:white">
            #include < stdio.h>
                #include < stdlib.h>
                
                // Structure to represent a binary search tree node
                struct TreeNode {
                    int data;
                    struct TreeNode *left;
                    struct TreeNode *right;
                };
                
                // Structure to represent a dynamic array
                struct DynamicArray {
                    int *array;
                    int size;
                };
                
                // Function to create a new binary search tree node
                struct TreeNode *createNode(int data) {
                    struct TreeNode *newNode = (struct TreeNode *)malloc(sizeof(struct TreeNode));
                    newNode->data = data;
                    newNode->left = newNode->right = NULL;
                    return newNode;
                }
                
                // Function to perform reverse inorder traversal of the binary search tree
                void reverseInorderTraversal(struct TreeNode *root, struct DynamicArray *array) {
                    if (root != NULL) {
                        reverseInorderTraversal(root->right, array);
                        array->array[array->size++] = root->data;
                        reverseInorderTraversal(root->left, array);
                    }
                }
                
                // Function to find the Kth largest element in the binary search tree
                int findKthLargest(struct TreeNode *root, int k) {
                    struct DynamicArray array;
                    array.array = (int *)malloc(sizeof(int) * 100); // Assuming a maximum of 100 elements
                    array.size = 0;
                
                    // Perform reverse inorder traversal and store elements in the array
                    reverseInorderTraversal(root, &array);
                
                    // Check if k is within the valid range
                    if (k > 0 && k <= array.size) {
                        // Return the Kth largest element
                        return array.array[k - 1];
                    } else {
                        // Invalid value of k
                        return -1;
                    }
                }
                
                // Function to free the memory allocated for a binary search tree
                void freeBST(struct TreeNode *root) {
                    if (root != NULL) {
                        freeBST(root->left);
                        freeBST(root->right);
                        free(root);
                    }
                }
                
                int main() {
                    // Create a sample binary search tree
                    struct TreeNode *root = createNode(5);
                    root->left = createNode(3);
                    root->right = createNode(8);
                    root->left->left = createNode(2);
                    root->left->right = createNode(4);
                    root->right->left = createNode(7);
                    root->right->right = createNode(9);
                
                    // Display the binary search tree (in reverse inorder traversal)
                    printf("Binary Search Tree (Reverse Inorder Traversal): ");
                    struct DynamicArray array;
                    array.array = (int *)malloc(sizeof(int) * 100);
                    array.size = 0;
                    reverseInorderTraversal(root, &array);
                    for (int i = 0; i < array.size; i++) {
                        printf("%d ", array.array[i]);
                    }
                    printf("\n");
                
                    // Find the Kth largest element in the binary search tree
                    int k = 3;
                    int kthLargest = findKthLargest(root, k);
                    if (kthLargest != -1) {
                        printf("The %dth largest element is: %d\n", k, kthLargest);
                    } else {
                        printf("Invalid value of k\n");
                    }
                
                    // Free the allocated memory for the binary search tree
                    freeBST(root);
                    free(array.array);
                
                    return 0;
                }
                           
        </code>
    </pre>
</body>
</html>