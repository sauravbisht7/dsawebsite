<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body style="background-color: black;">
    <pre>
        <code style="color:white">
            #include < stdio.h>
                #include < stdlib.h>
                
                // Structure to represent a binary search tree node
                struct TreeNode {
                    int data;
                    struct TreeNode *left;
                    struct TreeNode *right;
                };
                
                // Function to create a new binary search tree node
                struct TreeNode *createNode(int data) {
                    struct TreeNode *newNode = (struct TreeNode *)malloc(sizeof(struct TreeNode));
                    newNode->data = data;
                    newNode->left = newNode->right = NULL;
                    return newNode;
                }
                
                // Function to convert pre-order traversal to post-order traversal
                void preOrderToPostOrder(int preOrder[], int n, int *preIndex, int postOrder[], int *postIndex, int min, int max) {
                    // Base case: If all elements are processed
                    if (*preIndex == n) {
                        return;
                    }
                
                    // Check if the current element is within the valid range for a BST
                    if (preOrder[*preIndex] < min || preOrder[*preIndex] > max) {
                        return;
                    }
                
                    // Extract the current element and increment pre-order index
                    int value = preOrder[*preIndex];
                    (*preIndex)++;
                
                    // Recursively process left and right subtrees
                    preOrderToPostOrder(preOrder, n, preIndex, postOrder, postIndex, min, value);
                    preOrderToPostOrder(preOrder, n, preIndex, postOrder, postIndex, value, max);
                
                    // Store the current element in the post-order array
                    postOrder[*postIndex] = value;
                    (*postIndex)++;
                }
                
                // Function to print an array
                void printArray(int arr[], int n) {
                    for (int i = 0; i < n; i++) {
                        printf("%d ", arr[i]);
                    }
                    printf("\n");
                }
                
                int main() {
                    // Example pre-order traversal of a BST
                    int preOrder[] = {40, 30, 35, 80, 100};
                    int n = sizeof(preOrder) / sizeof(preOrder[0]);
                
                    // Initialize indices for pre-order and post-order arrays
                    int preIndex = 0;
                    int postIndex = 0;
                
                    // Create an array to store post-order traversal
                    int *postOrder = (int *)malloc(sizeof(int) * n);
                
                    // Convert pre-order to post-order
                    preOrderToPostOrder(preOrder, n, &preIndex, postOrder, &postIndex, INT_MIN, INT_MAX);
                
                    // Print the original pre-order traversal
                    printf("Original Pre-order Traversal: ");
                    printArray(preOrder, n);
                
                    // Print the converted post-order traversal
                    printf("Converted Post-order Traversal: ");
                    printArray(postOrder, n);
                
                    // Free the allocated memory
                    free(postOrder);
                
                    return 0;
                }
                             
        </code>
    </pre>
</body>
</html>